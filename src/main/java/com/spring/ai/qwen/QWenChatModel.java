package com.spring.ai.qwen;


import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.messages.MessageType;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.metadata.ChatGenerationMetadata;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestClient;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Configuration(value = "qwenChatModel")
public class QWenChatModel implements ChatModel {

    @Resource
    RestClient restClient;

    @Override
    public ChatResponse call(Prompt prompt) {
        Map<String, Object> requestBody = Map.of("model", QWenConfig.getModel(), "messages", convertMessages(prompt.getUserMessages()), "parameters", Map.of("result_format", "text"));

        ResponseEntity<ChatCompletion> response = restClient.post().uri("/chat/completions").body(requestBody).retrieve().toEntity(ChatCompletion.class);

        var chatCompletion = response.getBody();

        if (chatCompletion == null) {
            log.warn("No chat completion returned for prompt: {}", prompt);
            return new ChatResponse(List.of());
        }

        List<ChatCompletion.Choice> choices = chatCompletion.choices();
        if (choices == null) {
            log.warn("No choices returned for prompt: {}", prompt);
            return new ChatResponse(List.of());
        }

        List<Generation> generations = choices.stream().map(choice -> {
            // @formatter:off
            Map<String, Object> metadata = Map.of(
                    "id", chatCompletion.id() != null ? chatCompletion.id() : "",
                    "role", choice.message().role() != null ? choice.message().role().name() : "",
                    "index", choice.index(),
                    "finishReason", choice.finishReason() != null ? choice.finishReason() : "");
            // @formatter:on
            return buildGeneration(choice, metadata);
        }).toList();

        return new ChatResponse(generations);
    }


    private Generation buildGeneration(ChatCompletion.Choice choice, Map<String, Object> metadata) {

        String finishReason = (choice.finishReason() != null ? choice.finishReason() : "");
        var generationMetadataBuilder = ChatGenerationMetadata.builder().finishReason(finishReason);

        String textContent = choice.message().rawContent().toString();

        AssistantMessage message = AssistantMessage.builder().content(textContent).properties(metadata).media(new ArrayList<>()).toolCalls(new ArrayList<>()).build();
        return new Generation(message, generationMetadataBuilder.build());
    }

    private List<Map<String, String>> convertMessages(List<UserMessage> messages) {
        return messages.stream().map(msg -> Map.of("role", convertRole(msg.getMessageType()), "content", msg.getText())).collect(Collectors.toList());
    }

    private String convertRole(MessageType messageType) {
        switch (messageType) {
            case USER:
                return "user";
            case ASSISTANT:
                return "assistant";
            case SYSTEM:
                return "system";
            default:
                return "user";
        }
    }


    @JsonInclude(JsonInclude.Include.NON_NULL)
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ChatCompletion(// @formatter:off
                                 @JsonProperty("id") String id,
                                 @JsonProperty("choices") List<ChatCompletion.Choice> choices,
                                 @JsonProperty("created") Long created,
                                 @JsonProperty("model") String model,
                                 @JsonProperty("system_fingerprint") String systemFingerprint,
                                 @JsonProperty("object") String object,
                                 @JsonProperty("usage") Usage usage
    ) { // @formatter:on

        /**
         * Chat completion choice.
         *
         * @param finishReason The reason the model stopped generating tokens.
         * @param index        The index of the choice in the list of choices.
         * @param message      A chat completion message generated by the model.
         * @param logprobs     Log probability information for the choice.
         */
        @JsonInclude(JsonInclude.Include.NON_NULL)
        @JsonIgnoreProperties(ignoreUnknown = true)
        public record Choice(// @formatter:off
                             @JsonProperty("finish_reason") String finishReason,
                             @JsonProperty("index") Integer index,
                             @JsonProperty("message") ChatCompletionMessage message,
                             @JsonProperty("logprobs") String logprobs) { // @formatter:on
        }

    }


    @JsonInclude(JsonInclude.Include.NON_NULL)
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Usage(// @formatter:off
                        @JsonProperty("completion_tokens") Integer completionTokens,
                        @JsonProperty("prompt_tokens") Integer promptTokens,
                        @JsonProperty("total_tokens") Integer totalTokens,
                        @JsonProperty("prompt_tokens_details") Usage.PromptTokensDetails promptTokensDetails) { // @formatter:on

        public Usage(Integer completionTokens, Integer promptTokens, Integer totalTokens) {
            this(completionTokens, promptTokens, totalTokens, null);
        }

        /**
         * Breakdown of tokens used in the prompt
         *
         * @param cachedTokens Cached tokens present in the prompt.
         */
        @JsonInclude(JsonInclude.Include.NON_NULL)
        @JsonIgnoreProperties(ignoreUnknown = true)
        public record PromptTokensDetails(// @formatter:off
                                          @JsonProperty("cached_tokens") Integer cachedTokens) { // @formatter:on
        }
    }


    public record ChatCompletionMessage(// @formatter:off
                                        @JsonProperty("content") Object rawContent,
                                        @JsonProperty("role") Role role) { // @formatter:on


    }

    public enum Role {

        /**
         * System message.
         */
        @JsonProperty("system") SYSTEM,
        /**
         * User message.
         */
        @JsonProperty("user") USER,
        /**
         * Assistant message.
         */
        @JsonProperty("assistant") ASSISTANT,
        /**
         * Tool message.
         */
        @JsonProperty("tool") TOOL

    }
}
